using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BasicPreprocess.General.Containers
{
    /// <summary>
    /// A class to track the names of columns used as unique identifiers in tabular data, 
    /// and if necessary, hold a column of auto-incrementing indexes which may be dereferenced 
    /// on instances of their accompanying keys.
    /// <para>Probably not used outside of other General.Containers->KeyColumns internal sealed class.</para>
    /// </summary>
    internal sealed class _TKeyTypes
    {
        public string primaryKey;
        public (string Column1, Auto_Incr_IntMap<string>) redundandPrimaryKey;
        public List<string> compositeKey;
        public (List<string>, Auto_Incr_IntMap<List<String>>) redundantCompositeKey;

        /// <summary>
        /// Build a public tuple with a value in the primary key.
        /// </summary>
        /// <param name="primaryKey">A key with only one string which is unique in its column.</param>
        public _TKeyTypes(string primaryKey)
        {
            this.primaryKey = primaryKey;
            this.redundandPrimaryKey = (null, null);
            this.compositeKey = null;
            this.redundantCompositeKey = (null, null);
        }

        /// <summary>
        /// Build a public tuple with a value in the primaryRedundant key.
        /// </summary>
        /// <param name="primaryKey">The column of a key with only one string which is not unique in its column.</param>
        /// <param name="primaryIndexMap">A map of index ints, mapped on the primary key.</param>

        public _TKeyTypes(string primaryKey, Auto_Incr_IntMap<string> primaryIndexMap)
        {
            this.primaryKey = null;
            this.redundandPrimaryKey = (primaryKey, primaryIndexMap);
            this.compositeKey = null;
            this.redundantCompositeKey = (null, null);
        }

        /// <summary>
        /// Get the next unique index corresponding to a given primary key.
        /// </summary>
        /// <param name="primary_of_Item">A given primary key,
        /// generated by referencing an item in a column on the primary key.
        /// <br>For instance: a specific account number,
        /// if the primary key column is account numbers.</br>
        /// </param>
        /// <returns></returns>
        public (string, int) GetNextRedundantPrimaryKey(string primary_of_Item)
        {
            return (
                redundandPrimaryKey.Item1,
                redundandPrimaryKey.Item2[primary_of_Item]);
        }

        /// <summary>
        /// Build a public tuple with a value in the composite key.
        /// </summary>
        /// <param name="compositeKey">A key with two strings which together are a unique combination of strings in their columns.</param>

        public _TKeyTypes(List<string> compositeKey)
        {
            this.primaryKey = null;
            this.redundandPrimaryKey = (null, null);
            this.compositeKey = compositeKey;
            this.redundantCompositeKey = (null, null);
        }

        /// <summary>
        /// Build a public tuple with a value in the compositeRedundant key.
        /// </summary>
        /// <param name="compositeKey">A key with two strings which together are a combination of strings
        ///     in their columns which are redundant with only a few others.</param>
        /// <param name="compositeIndexMap">A map in index ints, mapped on the composite key.</param>
        public _TKeyTypes(List<string> compositeKey
            , Auto_Incr_IntMap<List<string>> compositeIndexMap)
        {
            this.primaryKey = null;
            this.redundandPrimaryKey = (null, null);
            this.compositeKey = null;
            this.redundantCompositeKey = (compositeKey, compositeIndexMap);
        }

        /// <summary>
        /// Get the next key with this composite signature.
        /// </summary>
        /// <param name="keys"></param>
        /// <returns></returns>
        public (List<string>, int) GetNextRedundantCompositeKey(List<string> keys)
        {
            return (keys, keys.Count);
        }
    }
}